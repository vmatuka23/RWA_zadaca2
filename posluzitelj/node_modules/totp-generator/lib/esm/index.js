export class TOTP{static _sign=async(t,e,r)=>{try{const a=(globalThis.crypto||require("node:crypto").webcrypto).subtle,i=await a.importKey("raw",t,{name:"HMAC",hash:{name:r}},!1,["sign"]),n=TOTP.hex2buf(e);return await a.sign("HMAC",i,n)}catch(a){const{default:i}=await import("jssha"),n=new i(r,"ARRAYBUFFER");return n.setHMACKey(t,"ARRAYBUFFER"),n.update(TOTP.hex2buf(e)),n.getHMAC("ARRAYBUFFER")}};static async generate(t,e){const r={digits:6,algorithm:"SHA-1",encoding:"hex",period:30,timestamp:Date.now(),explicitZeroPad:!1,...e},a=Math.floor(r.timestamp/1e3),i=TOTP.dec2hex(Math.floor(a/r.period)).padStart(16,"0"),n="hex"===r.encoding?TOTP.base32ToBuffer(t):TOTP.asciiToBuffer(t),o=await TOTP._sign(n,i,r.algorithm),s=TOTP.buf2hex(o),c=2*TOTP.hex2dec(s.slice(-1)),h=(2147483647&TOTP.hex2dec(s.slice(c,c+8))).toString().slice(-r.digits),T=r.explicitZeroPad?h.padStart(r.digits,"0"):h,d=1e3*r.period;return{otp:T,expires:Math.ceil((r.timestamp+1)/d)*d}}static hex2dec(t){return parseInt(t,16)}static dec2hex(t){return(t<15.5?"0":"")+Math.round(t).toString(16)}static base32ToBuffer(t){let e=(t=t.toUpperCase()).length;for(;61===t.charCodeAt(e-1);)e--;const r=new Uint8Array(5*e/8);let a=0,i=0,n=0;for(let o=0;o<e;o++){const e=TOTP.base32[t.charCodeAt(o)];if(void 0===e)throw new Error("Invalid base32 character in key");a=a<<5|e,i+=5,i>=8&&(r[n++]=a>>>(i-=8))}return r.buffer}static asciiToBuffer(t){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e.buffer}static hex2buf(t){const e=new Uint8Array(t.length/2);for(let r=0,a=0;r<t.length;r+=2,a++)e[a]=TOTP.hex2dec(t.slice(r,r+2));return e.buffer}static buf2hex(t){return[...new Uint8Array(t)].map(t=>t.toString(16).padStart(2,"0")).join("")}static base32={50:26,51:27,52:28,53:29,54:30,55:31,65:0,66:1,67:2,68:3,69:4,70:5,71:6,72:7,73:8,74:9,75:10,76:11,77:12,78:13,79:14,80:15,81:16,82:17,83:18,84:19,85:20,86:21,87:22,88:23,89:24,90:25}}
//# sourceMappingURL=index.js.map