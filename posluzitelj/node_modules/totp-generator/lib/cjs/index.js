"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,i){void 0===i&&(i=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,i,n)}:function(e,t,r,i){void 0===i&&(i=r),e[i]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(){var e=function(t){return e=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t},e(t)};return function(t){if(t&&t.__esModule)return t;var r={};if(null!=t)for(var i=e(t),n=0;n<i.length;n++)"default"!==i[n]&&__createBinding(r,t,i[n]);return __setModuleDefault(r,t),r}}();Object.defineProperty(exports,"__esModule",{value:!0}),exports.TOTP=void 0;class TOTP{static _sign=async(e,t,r)=>{try{const i=(globalThis.crypto||require("node:crypto").webcrypto).subtle,n=await i.importKey("raw",e,{name:"HMAC",hash:{name:r}},!1,["sign"]),a=TOTP.hex2buf(t);return await i.sign("HMAC",n,a)}catch(i){const{default:n}=await Promise.resolve().then(()=>__importStar(require("jssha"))),a=new n(r,"ARRAYBUFFER");return a.setHMACKey(e,"ARRAYBUFFER"),a.update(TOTP.hex2buf(t)),a.getHMAC("ARRAYBUFFER")}};static async generate(e,t){const r={digits:6,algorithm:"SHA-1",encoding:"hex",period:30,timestamp:Date.now(),explicitZeroPad:!1,...t},i=Math.floor(r.timestamp/1e3),n=TOTP.dec2hex(Math.floor(i/r.period)).padStart(16,"0"),a="hex"===r.encoding?TOTP.base32ToBuffer(e):TOTP.asciiToBuffer(e),o=await TOTP._sign(a,n,r.algorithm),c=TOTP.buf2hex(o),s=2*TOTP.hex2dec(c.slice(-1)),u=(2147483647&TOTP.hex2dec(c.slice(s,s+8))).toString().slice(-r.digits),l=r.explicitZeroPad?u.padStart(r.digits,"0"):u,f=1e3*r.period;return{otp:l,expires:Math.ceil((r.timestamp+1)/f)*f}}static hex2dec(e){return parseInt(e,16)}static dec2hex(e){return(e<15.5?"0":"")+Math.round(e).toString(16)}static base32ToBuffer(e){let t=(e=e.toUpperCase()).length;for(;61===e.charCodeAt(t-1);)t--;const r=new Uint8Array(5*t/8);let i=0,n=0,a=0;for(let o=0;o<t;o++){const t=TOTP.base32[e.charCodeAt(o)];if(void 0===t)throw new Error("Invalid base32 character in key");i=i<<5|t,n+=5,n>=8&&(r[a++]=i>>>(n-=8))}return r.buffer}static asciiToBuffer(e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t.buffer}static hex2buf(e){const t=new Uint8Array(e.length/2);for(let r=0,i=0;r<e.length;r+=2,i++)t[i]=TOTP.hex2dec(e.slice(r,r+2));return t.buffer}static buf2hex(e){return[...new Uint8Array(e)].map(e=>e.toString(16).padStart(2,"0")).join("")}static base32={50:26,51:27,52:28,53:29,54:30,55:31,65:0,66:1,67:2,68:3,69:4,70:5,71:6,72:7,73:8,74:9,75:10,76:11,77:12,78:13,79:14,80:15,81:16,82:17,83:18,84:19,85:20,86:21,87:22,88:23,89:24,90:25}}exports.TOTP=TOTP;
//# sourceMappingURL=index.js.map